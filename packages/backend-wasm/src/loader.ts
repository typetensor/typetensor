/**
 * WASM module loader
 * 
 * Handles loading and initialization of the WebAssembly module
 * generated by wasm-pack.
 */

import type { WASMModule, WASMLoadOptions } from './types';

// Import the wasm-pack generated module
import init, * as wasmBindings from '../pkg/typetensor_wasm.js';

// Global WASM module instance
let wasmModule: WASMModule | null = null;
let wasmPromise: Promise<WASMModule> | null = null;

/**
 * Load the WASM module with the specified options
 * 
 * @param options Loading options
 * @returns Promise resolving to the loaded WASM module
 */
export async function loadWASMModule(options: WASMLoadOptions = {}): Promise<WASMModule> {
  // Return existing promise if already loading
  if (wasmPromise) {
    if (options.debug) {
      console.log('[WASM] Returning existing loading promise');
    }
    return wasmPromise;
  }
  
  // Return cached module if already loaded
  if (wasmModule) {
    if (options.debug) {
      console.log('[WASM] Returning cached module');
    }
    return wasmModule;
  }

  if (options.debug) {
    console.log('[WASM] Loading fresh WASM module');
  }

  // Start loading
  wasmPromise = loadWASMModuleInternal(options);
  
  try {
    wasmModule = await wasmPromise;
    return wasmModule;
  } catch (error) {
    // Reset promise on failure so we can retry
    wasmPromise = null;
    throw error;
  }
}

/**
 * Internal WASM module loading implementation
 */
async function loadWASMModuleInternal(options: WASMLoadOptions): Promise<WASMModule> {
  const { debug = false } = options;

  if (debug) {
    console.log('[WASM] Loading TypeTensor WASM backend...');
  }

  try {
    // Initialize the wasm-pack generated module
    const wasmInitResult = await init();
    
    // The bindings are now available
    const module: WASMModule = {
      // Memory is directly available from the init result
      memory: wasmInitResult?.memory || new WebAssembly.Memory({ initial: 256 }),
      
      // Core functions
      greet: wasmBindings.greet,
      get_version: wasmBindings.get_version,
      
      // Classes and types
      WasmOperationDispatcher: wasmBindings.WasmOperationDispatcher,
      WasmMemoryManager: wasmBindings.WasmMemoryManager,
      WasmBufferHandle: wasmBindings.WasmBufferHandle,
      WasmTensorMeta: wasmBindings.WasmTensorMeta,
      
      // Utility functions
      has_simd_support: wasmBindings.has_simd_support,
      has_shared_memory_support: wasmBindings.has_shared_memory_support,
      get_optimal_thread_count: wasmBindings.get_optimal_thread_count,
    };
    
    if (debug) {
      console.log('[WASM] Module loaded successfully');
      console.log('[WASM] Version:', module.get_version());
    }

    return module;
  } catch (error) {
    console.error('[WASM] Failed to load module:', error);
    throw new Error(`Failed to initialize WASM module: ${error}`);
  }
}

/**
 * Get the loaded WASM module (throws if not loaded)
 */
export function getLoadedWASMModule(): WASMModule {
  if (!wasmModule) {
    throw new Error('WASM module not loaded. Call loadWASMModule() first.');
  }
  return wasmModule;
}

/**
 * Check if the WASM module is loaded
 */
export function isWASMModuleLoaded(): boolean {
  return wasmModule !== null;
}

/**
 * Reset the WASM module (for testing)
 */
export function resetWASMModule(): void {
  wasmModule = null;
  wasmPromise = null;
}